{"posts":[{"title":"1000种炼丹手法","text":"本文主要用来记录笔者在日常开发过程中常用的方法。 python训练时指定GPU 参考自文章 在py文件里指定12345678910111213141516import osos.environ[&quot;CUDA_DEVICE_ORDER&quot;] = &quot;PCI_BUS_ID&quot; #可不写os.environ[&quot;CUDA_VISIBLE_DEVICES&quot;] = &quot;0&quot; #0就是指定GPU 0 跑实验，可按需修改成其他GPU# 设置定量的GPU使用量(如果是TensorFlow框架）import tensorflow as tfconfig = tf.ConfigProto() config.gpu_options.per_process_gpu_memory_fraction = 0.9 # 占用GPU90%的显存 session = tf.Session(config=config)# 设置最小的GPU使用量config = tf.ConfigProto() config.gpu_options.allow_growth = True (or) 在终端指定1CUDA_VISIBLE_DEVICES=0 python your_code.py #0表示GPU0，按需修改 动态查看GPU占用率12watch -n1 nvidia-smi 数字`1` 表示每1秒刷新界面 使用Screen解决ssh连接中断导致的训练中断问题 安装screen 1sudo apt-get install screen 创建一个会话窗口(Session) 12$ screen -S SessionNamescreen -S train 列出所有的会话窗口 1234$ screen -lsThere is a screen on: 1622.train (01/31/21 19:32:12) (Attached)1 Socket in /run/screen/S-root. 进入指定窗口 123screen -r 1622 # 1622为session的连接id# 或者也可以screen -r SessionName # 对应1622的话此处应为train 与窗口分离 1screen -d 1622 重新连接窗口 123screen -x 1622# 如有需要可以先分离再重新连接screen -d -r 1622 删除窗口 1screen -X -S 1622 quit 远程查看部署在服务器上的Tensorboardwindows系统 在Windows系统装一个Xshell或FinalShell，编辑SSH连接→隧道→添加，类型为local（本地），源主机（绑定ip）填127.0.0.1，端口随意设置一个未使用的端口如12345，目标主机为服务器ip，目标端口一般是6006，也可改成其他端口。 在服务器上运行 tensorboard --logdir='logs' --port 6006。 在本机打开网页127.0.0.1:12345 Mac或Linux系统 在登录远程服务器的时候使用命令： 1ssh -L 16006:127.0.0.1:6006 account@server.address 训练完模型之后使用如下命令： 1tensorboard --logdir=&quot;/path/to/log-directory&quot; 最后，在本地访问地址：http://127.0.0.1:16006/ 估算一个深度模型的计算量和参数ߒᠥߥ꩔HOP: PyTorch-OpCounter Official URL: https://github.com/Lyken17/pytorch-OpCounter 安装 123pip install thop# orpip install --upgrade git+https://github.com/Lyken17/pytorch-OpCounter.git 使用 基础用法 12345from torchvision.models import resnet50from thop import profilemodel = resnet50()input = torch.randn(1, 3, 224, 224)macs, params = profile(model, inputs=(input,)) 对第三方模块定义规则 123456789class YourModule(nn.Module) # your definitiondef count_your_model(model, x, y): # your rule hereinput = torch.randn(1, 3, 224, 224)macs, params = profile(model, inputs=(input,), custom_ops={YourModule: count_your_model}) 改善profile输出可读性 调用thop.clever_format对profile结果格式化 12from thop import clever_formatmacs, params = clever_format([macs, params], &quot;%.3f&quot;) DistributedDataParallel (DDP)Concepts rank：用于表示进程的编号/序号（在一些结构图中rank指的是软节点，rank可以看成一个计算单位），每一个进程对应了一个rank的进程，整个分布式由许多rank完成。 node：物理节点，可以是一台机器也可以是一个容器，节点内部可以有多个GPU。 rank与local_rank： rank是指在整个分布式任务中进程的序号；local_rank是指在一个node上进程的相对序号，local_rank在node之间相互独立。（注意：在代码中，会使用local_rank来指定GPU，并且local_rank和实际的gpu编号存在映射关系，比如，指定gpu 4,5进行训练，local_rank仍然是0,1，但前提是要先设置os.environ[‘CUDA_VISIBLE_DEVICES’] = “4,5”）。 nnodes、node_rank与nproc_per_node： nnodes是指物理节点数量，node_rank是物理节点的序号；nproc_per_node是指每个物理节点上面进程的数量。 word size ： 全局（一个分布式任务）中，rank的数量。 💡 RANK是全局进程的序号，而LOCAL_RANK可以理解为每个进程中线程的序号。 Examples 获取全局变量 12345import osLOCAL_RANK = int(os.getenv('LOCAL_RANK', -1))RANK = int(os.getenv('RANK', -1))WORLD_SIZE = int(os.getenv('WORLD_SIZE', 1)) 根据LOCAL_RANK给每一个计算节点分配GPU 123456if LOCAL_RANK != -1: assert torch.cuda.device_count() &gt; LOCAL_RANK, 'insufficient CUDA devices for DDP command' print(&quot;torch.cuda.device_count():&quot;, torch.cuda.device_count()) torch.cuda.set_device(LOCAL_RANK) device = torch.device(&quot;cuda&quot;, LOCAL_RANK) dist.init_process_group(backend=&quot;nccl&quot; if dist.is_nccl_available() else &quot;gloo&quot;) 仅在主进程中保存日志信息，避免打印混乱 12345678# loggerif RANK in {-1, 0}: logger.info(&quot;Message...&quot;)# pbarpbar = enumerate(train_loader) if RANK in {-1, 0}: pbar = tqdm(pbar, total=steps_per_epoch, desc='Epoch {}/{}'.format(epoch, args.max_epochs)) 在单机单卡以外的模式，需要设置分布式采样器 1234from torch.utils.data import distributeddataset = Dataset()sampler = None if LOCAL_RANK == -1 else distributed.DistributedSampler(dataset, shuffle=True) 在主进程以外的进程中封装DDP 1234567from torch.nn.parallel import DistributedDataParallel as DDPif RANK != -1: # Sync batch norm model = torch.nn.SyncBatchNorm.convert_sync_batchnorm(model).to(device) # DDP model = DDP(model, device_ids=[LOCAL_RANK], output_device=LOCAL_RANK) Shell commonds123456789101112131415161718192021# 命令行指定GPU设备# 单机单卡python main.py --device 0# 单机多卡python -m torch.distributed.launch --nproc_per_node 2 main.py# 指定某几张GPUpython -m torch.distributed.launch --nproc_per_node 2 main.py --device 0,3# 多机多卡# - master_address: master进程的网络地址# - master_port: master进程的一个端口，默认29500，使用前需要确认端口是否被其他程序占用# 节点0python -m torch.distributed.launch --nproc_node=8 --nnodes=2 --node_rank=0 --master_address=&quot;192.168.0.1&quot; --master_port=12345 train.py# 节点1python -m torch.distributed.launch --nproc_node=8 --nnodes=2 --node_rank=1 --master_address=&quot;192.168.0.1&quot; --master_port=12345 train.py Automatic Mixed Precision (AMP)举例: 12345678910111213141516import torchscaler = torch.cuda.amp.GradScaler(enabled=True)optimizer.zero_grad()# Casts operations to mixed precisionwith torch.cuda.amp.autocast(enabled=True): loss = model(data)# Scales the loss, and call backward() to create scaled gradientsscaler.scale(loss).backward()# Unscales gradients and calls or skips optimizer.step()scaler.step(optimizer)# Updates the scale for next iterationscaler.update()","link":"/2023/11/17/1000%E7%A7%8D%E7%82%BC%E4%B8%B9%E6%89%8B%E6%B3%95/"},{"title":"Docker常用命令","text":"本文简单记录Docker服务常用的命令。 Docker服务 启动Docker 守护进程 1systemctl daemon-reload Docker启动命令： 1systemctl start docker 查看docker服务是否启动 1ps -ef | grep docker 查看docker启动的服务： 1docker ps 停止docker服务 1systemctl stop docker 重启docker服务 1systemctl restart docker 容器的导入/导出/删除 查看镜像（必须是正在运行中的） 1docker ps 导出某个容器 1docker export $container_id &gt; [容器快照名.tar] 导入某个容器 1cat [容器快照名.tar] | docker import - [IMAGE] 保存容器到镜像 1docker commit [OPTIONS] [CONTAINER ID] [IMAGE] OPTIONS说明： a: 提交的镜像作者； c: 使用Dockerfile指令来创建镜像； m: 提交时的说明文字； p: 在commit时，将容器暂停。 删除容器 1docker rm -f [容器id] 镜像的导入/保存/载入/删除 查看镜像 1docker images 导入镜像 1cat [镜像文件] | docker import - [IMAGE] 保存镜像 12docker save -o [要保存的镜像名字] [要保存的镜像]docker save REPOSITORY:TAG &gt; /path/to/file.tar 载入镜像 1docker load &lt; [本地的镜像名字] 删除镜像 123456789 docker rmi -f [image_id] ``` # 应用场景## 进入容器```bashdocker exec -it [container_name] bash 多个docker挂载同一个宿主机的文件目录第一个容器使用 1docker run -it --privileged=true --name docker1 -v /data-volume/:/data-volume centos 第二个~第N个容器 1docker run -it --privileged=true --name docker2 --volumes-from docker1 centos 主要参数说明: -privileged=true //代表赋予容器特权,可以对挂载的目录进行读写操作 v /data-volume/:/data-volume //将宿主机的目录/data-volume挂载到容器中的/data-volume目录(只需要第一个容器这样挂载，剩下的容器使用–volumes-from参数) -volumes-from //参数后面跟着的docker1 是数据卷容器名字，也就是第一个容器的名字，这里第一个容器就被当做数据卷容器了。 –name //容器的名字，必须唯一，与其他的容器名字不可重复","link":"/2023/11/16/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"title":"Git常用命令","text":"本文粗略记录笔者关于使用Git的主要命令。 配置账户12git config --global user.name &quot;your name&quot;git config --global user.email &quot;your email address&quot; 代理socks512git config --global http.proxy socks5://127.0.0.1:1080git config --global https.proxy socks5://127.0.0.1:1080 http/https12git config --global http.proxy http://127.0.0.1:1080git config --global https.proxy https://127.0.0.1:1080 重置12git config --global --unset http.proxygit config --global --unset https.proxy 基础命令pull描述：用于从远程获取代码并合并本地的版本。 命令使用： 1git pull &lt;远程主机名&gt; &lt;远程分支&gt;:&lt;本地分支&gt; 相关命令： 12345# 将远程主机origin的master分支拉去过来，与本地的branchtest分支合并。git pull origin master:branchtest#如果远程分支是与当前分支合并，则冒号后面的部分可以省略。git pull origin master commit描述： 命令使用： 相关命令： push描述： 命令使用： 相关命令： 进阶命令stash描述：该命令将保存本地修改，并恢复干净的工作目录。 应用场景：当想切换分支，但是当前分支有文件更改了，需要保持工作区干净才能切分支。 命令使用： 1git stash 相关命令： 1234567891011121314151617# 保存当前未commit的代码并添加备注git stash save &quot;备注的内容&quot;# 列出stash的所有记录git stash list# 删除stash的所有记录git stash clear# 应用最近一次的stashgit stash apply# 应用最近一次的stash，随后删除该记录git stash pop# 删除最近的一次stashgit stash drop git仓库提交分支到另一个仓库假设有仓库repo_a和仓库repo_b，目的是要将仓库repo_a的branch_test分支提交到仓库repo_b。 先将repo_a拉取到本地 1git clone https://github.com/.../repo_a.git 创建一个分支，起点master（如果已有分支跳过该步骤） 1git branch branch_test master 添加repo_b的远程地址 1git remote add repo_b_branch https://github.com/.../repo_b.git 可以查看已有的远程路径 1git remote -v 推送branch_test分支到repo_b 如果要使用另外的分支名，例如repo_b_new_branch，在分支后面使用冒号加新的分支名称 1git push repo_b_branch branch_test:repo_b_new_branch 如果远程已有该分支，推送会报错 需要先从远程拉取，在本地merge以后，可以提交。 克隆远程仓库的指定分支1git clone -b branchA https://github.com/.../repo.git 拉取另一个远程仓库的指定分支 首先在本地仓库添加远程仓库地址 1git remote add origin/&lt;branch&gt; https://github.com/.../xxx.git 然后拉取指定分支 1git pull origin &lt;branch&gt; Git submodule以库或模块的形式在项目中使用第三代码，又和自己的代码隔离 创建一个文件夹用于存储第三方库 12mkdir libcd lib 将第三方库以submodule的方式注入到项目中 1git submodule add https://github.com/xxx/xxx.git 第三方库将会被clone到文件夹中","link":"/2023/11/14/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"title":"Homebrew","text":"本文简单记录安装Homebrew的步骤。 安装方法一：brew官网的安装脚本执行下列命令 1/bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)&quot; 该方法极不稳定，原因是 https://raw.githubusercontent.com 访问不稳定。 方法二：brew镜像安装脚本（推荐）1/bin/bash -c &quot;$(curl -fsSL https://cdn.jsdelivr.net/gh/ineo6/homebrew-install/install.sh)&quot; 更新1brew update 替换更新源123456789101112131415161718192021222324# 替换brew.git:cd &quot;$(brew --repo)&quot;# 中国科大:git remote set-url origin https://mirrors.ustc.edu.cn/brew.git# 清华大学:git remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/brew.git# 替换homebrew-core.git:cd &quot;$(brew --repo)/Library/Taps/homebrew/homebrew-core&quot;# 中国科大:git remote set-url origin https://mirrors.ustc.edu.cn/homebrew-core.git# 清华大学:git remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-core.git# 替换homebrew-bottles:# 中国科大:echo 'export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.ustc.edu.cn/homebrew-bottles' &gt;&gt; ~/.bash_profilesource ~/.bash_profile# 清华大学:echo 'export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles' &gt;&gt; ~/.bash_profilesource ~/.bash_profile# 应用生效:brew update 如果你之前折腾过不少导致你的 Homebrew 有点问题，那么可以尝试使用如下方案： 123456789101112131415# 诊断Homebrew的问题:brew doctor# 重置brew.git设置:cd &quot;$(brew --repo)&quot;git fetchgit reset --hard origin/master# homebrew-core.git同理:cd &quot;$(brew --repo)/Library/Taps/homebrew/homebrew-core&quot;git fetchgit reset --hard origin/master# 应用生效:brew update 重置更新源 某些时候也有换回官方源的需求12345# 重置brew.git:cd &quot;$(brew --repo)&quot;$ git remote set-url origin https://github.com/Homebrew/brew.git# 重置homebrew-core.git:cd &quot;$(brew --repo)/Library/Taps/homebrew/homebrew-core&quot;$ git remote set-url origin https://github.com/Homebrew/homebrew-core.git Thanks Mac安装Homebrew的正确姿势 update Homebrew 太慢，更换Homebrew的更新源","link":"/2023/11/17/Homebrew/"},{"title":"Linux实现远程桌面环境","text":"本文简单记录在Linux实现远程连接桌面环境所需安装的依赖。 环境安装 安装xfce4和xrdp 12sudo apt-get update -ysudo apt-get install -y xfce4 xrdp --fix-missing 修改默认配置 1234567891011121314$ sudo vim /etc/xrdp/xrdp.ini# 修改默认的通信端口3389，防止和windows系统的远程桌面冲突port=3390# 修改Xorg配置部分以保存登录使用的账号密码，即可实现免密登录[Xorg]name=Xorglib=libxup.sousername=[USERNAME]password=[PASSWORD]ip=127.0.0.1port=-1code=20 指定session会话 1echo &quot;xfce4-session&quot; &gt;&gt; ~/.xsession 启用服务1sudo /etc/init.d/xrdp start","link":"/2023/11/17/Linux%E5%AE%9E%E7%8E%B0%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E7%8E%AF%E5%A2%83/"},{"title":"SSH","text":"本文粗略记录了关于SSH命令的安装和常见使用。 安装 安装ssh服务 1apt-get install openssh-server 修改ssh配置,允许root登录 一般进入容器时使用的都是 root 账号，但是 ssh 默认是禁止 root 账号使用密码远程登录的，所以需要修改 ssh 配置文件使其允许： 1234vim /etc/ssh/sshd_config# 将PermitRootLogin的值从withoutPassword改为yes（去掉前面的#号）# 如果没有vim可以安装个：apt-get install vim 启动ssh服务 1service ssh start 判断ssh服务是否成功启动 12345678910在终端中输入：ps -e|grep ssh，可以查看是否启动成功，如果有sshd，就说明启动成功。$ sudo ps -e | grep ssh 4031 ? 00:00:00 sshd------对应服务器端sshd表示ssh-server启动了另外还可以查看网络连接状态sudo netstat -tnlp 命令格式1ssh [OPTIONS] [-p PORT] [USER@]HOSTNAME [COMMAND] 选项说明： -1 强制只使用协议第一版 -2 强制只使用协议第二版 -4 强制只使用 IPv4 地址-6 强制只使用 IPv6 地址-A 允许转发认证代理的连接。可以在配置文件中对每个主机单独设定这个参数-a 禁止转发认证代理的连接-b BIND_ADDRESS 在拥有多个地址的本地机器上，指定连接的源地址-C 压缩所有数据。压缩算法与 gzip(1) 使用的相同-c {blowfish | 3des | des} 选择会话的密码算法。3des 是默认算法-c CIPHER_SPEC 另外, 对于协议第二版，这里可以指定一组用逗号隔开、按优先顺序排列的加密算法-D [BIND_ADDRESS:]PORT 指定一个本地主机动态的应用程序级的转发端口。工作原理是这样的，本地机器上分配了一个 socket 侦听 port 端口，一旦这个端口上有了连接，该连接就经过安全通道转发出去，根据应用程序的协议可以判断出远程主机将和哪里连接。目前支持 SOCKS4 和 SOCKS5 协议，而 ssh 将充当 SOCKS 服务器. 只有 root 才能转发特权端口。可以在配置文件中指定动态端口的转发-e ESCAPE_CHAR 设置 pty 会话的转义字符，默认为字符 ~。转义字符只在行首有效，转义字符后面跟一个点表示结束连接，后跟一个 control-Z 表示挂起连接，跟转义字符自己表示输出转义字符自身。把转义字符设为 none 则禁止 转义功能，使会话完全透明-F CONFIGFILE 指定 ssh 指令的配置文件，将忽略系统级配置文件 /etc/ssh/ssh_config 和用户级配置文件 ~/.ssh/config-f ssh 在执行命令前退至后台-g 允许远端主机连接本地的转发端口-I SMARTCARD_DEVICE 指定智能卡设备。智能卡里面存储了用户的 RSA 私钥-i IDENTITY_FILE 指定一个 RSA 或 DSA 认证所需的身份（私钥）文件。协议第一版的默认文件是 ~/.ssh/identity 以及协议第二版的 ~/.ssh/id_rsa 和 ~/.ssh/id_dsa 文件。可以同时使用多个 -i 选项，也可以在配置文件中指定多个身份文件-K 启用基于 GSSAPI 的身份验证和向服务器转发 GSSAPI 凭据-k 禁用向服务器转发 GSSAPI 凭据-L [BIND_ADDRESS:]PORT:HOST:HOSTPORT 将本地主机的地址和端口接收到的数据通过安全通道转发给远程主机的地址和端口-l LOGIN_NAME 指定登录远程主机的用户。可以在配置文件中对每个主机单独设定这个参数-M 将 ssh 客户端置于主模式进行连接共享。多个 -M 选项将 ssh 置于主模式，并在接受从连接之前进行确认-m MAC_SPEC 对于协议第二版，可以指定一组用逗号隔开，按优先顺序排列的 MAC (message authentication code) 算法-N 不执行远程命令，用于转发端口。仅限协议第二版-n 把 stdin 重定向到 /dev/null，防止从 stdin 读取数据。在后台运行时一定会用到这个选项-O CTL_CMD 控制主动连接多路复用主进程。参数 CTL_CMD 将被传递给主进程。CTL_CMD 可取值 check（检查主进程是否正在运行）和 exit（让主进程退出）-o OPTION 可以在这里给出某些选项，格式和配置文件中的格式一样。它用来设置那些没有单独的命令行标志的选项-p PORT 指定远程主机的端口。可以在配置文件中对每个主机单独设定这个参数-q 安静模式。消除大多数的警告和诊断信息-R [BIND_ADDRESS:]PORT:HOST:HOSTPORT 将远程主机上的地址和端口接收的数据通过安全通道转发给本地主机的地址和端口-S CTL_PATH 指定用于连接共享的控制套接字的位置-s 用于请求远程系统上的子系统调用。子系统是 SSH2 协议的一个特性，它有助于将 SSH 用作其他应用程序（如 sftp(1)）的安全传输。子系统通过远程命令指定-T 禁止分配伪终端-t 强制分配伪终端。这可用于在远程计算机上执行基于屏幕的任意程序，例如菜单服务。多个 -t 选项强制分配终端, 即使没有本地终端-V 显示版本信息并退出-v 冗详模式。打印关于运行情况的调试信息。在调试连接、认证和配置问题时非常有用。多个 -v 选项能够增加冗详程度，最多三个-W HOST:PORT 将客户端上的标准输入和输出通过安全通道转发给指定主机的端口-w LOCAL_TUN[:REMOTE_TUN] 指定客户端和服务端之间转发的隧道设备-X 允许 X11 转发，可以在配置文件中对每个主机单独设定这个参数-x 禁止 X11 转发-Y 启用受信任的 X11 转发。受信任的 X11 转发不受 X11 安全扩展控制的约束-y 使用 syslog(3) 系统模块发送日志信息。默认情况下，此信息被发送到 stderr 免密登录/SSH密钥登录 在客户端生成公私钥 1ssh-keygen 上传公钥到服务器 如果是Linux &amp; Unix系统，输入下列命令： 1ssh-copy-id -i ~/.ssh/id_rsa.pub user@hosts 如果是Windows系统或者无网络环境的情况下，输入下列命令： 1cat ~/.ssh/id_rsa.pub | ssh user@host &quot;mkdir ~/.ssh &amp;&amp; cat &gt;&gt; ~/.ssh/authorized_keys &amp;&amp; chmod 600 ~/.ssh/authorized_keys &amp;&amp; chmod700 ~/.ssh&quot; [可选]修改服务器sshd_config配置文件 要允许使用密钥（公钥/私钥）登录，需要修改/etc/ssh/sshd_config文件中以下几个配置： 将PubkeyAuthentication设置为yes，表示启用公钥认证方式。 将AuthorizedKeysFile设置为存储公钥的路径和文件名，例如：AuthorizedKeysFile ~/.ssh/authorized_keys，表示公钥文件存储在当前用户的.ssh目录下的authorized_keys文件中。 将PasswordAuthentication设置为no，表示禁用密码认证方式，只允许使用公钥认证方式登录。这样可以增加系统的安全性。 要禁用SSH密钥身份验证，只需将/etc/ssh/sshd_config文件中的PasswordAuthentication，ChallengeResponseAuthentication，UsePAM指令改为no。 对本地id_rsa密钥设置密码 我们可以使用命令对本地已有的id_rsa密钥进行加密: 1ssh-keygen -p -f ~/.ssh/id_rsa 命令中的-p参数表示修改密码，-f参数指定要修改密码的密钥文件。完成后，id_rsa 密钥文件就被加密了。下次使用该密钥时，需要输入密码才能使用。 如果想要去除本地id_rsa密钥的密码，可以使用以下命令： 1ssh-keygen -p -f ~/.ssh/id_rsa -P &lt;old_password&gt; -N &quot;&quot; 命令中的-p参数表示修改密码，-f参数指定要修改密码的密钥文件，-P参数指定原来的密码，-N参数指定新的密码。在这个命令中，我们将新密码设置为空字符串，这样就相当于去除了原来的密码。完成后，id_rsa 密钥文件就被去除了密码。下次使用该密钥时，无需输入密码即可使用。 Key Error键入下列命令以清除密钥信息： 1ssh-keygen -R [ip_address]","link":"/2023/11/17/SSH/"},{"title":"Ubuntu基础知识","text":"本文简单记录笔者在Ubuntu系统安装和初始化时进行的操作。 系统安装 Through镜像 下载官方镜像，制作成启动盘 格式化一块硬盘分区，再按下面的方式划分系统分区 (最简) swap 逻辑分区 电脑内存1-2倍（我的是16GB内存，所以设置为16GB） / 逻辑分区或主分区 Ext4日志文件系统 余下空间 /home 可以考虑给用户文件夹单独一个分区 划分好分区后，需要注意的是挂载点为“/”的那一行，前面设备那一列显示应该是/dev/sdaX,X是一个阿拉伯数字，具体是几每个人不一样，表示的是你的/分区按在硬盘的第几块位置，记住/这个分区的sda后面是什么数字，然后在下面安装启动引导器设备：处，选择sdaX（X是一个阿拉伯数字）的那一项，也就是说，要将启动引导器安装在/分区中。 Through虚拟机 待补充… ubuntu启动引导 编辑grub配置文件：sudo vim /etc/default/grub 注释掉：GRUB_TIMEOUT_STYLE=hidden 修改grub等待时间，单位是秒：GRUB_TIMEOUT=10 编辑：GRUB_CMDLINE_LINUX_DEFAULT=”text” 修改默认启动项 12GRUB_DEFAULT = saved # 上一次启动的选择项GRUB_DEFAULT= 2 # 这个是选择第三项：Windows 执行sudo update-grub命令应用修改 Windows、Ubuntu双系统时差终端执行命令 1timedatectl set-local-rtc 1 --adjust-system-clock issueswifi无法连接解决方案搜索不到附近的wifi热点，原因是ubuntu默认关闭了联想Y7000的wifi硬件，即硬阻塞显示无线和蓝牙状态，可查看状态： rfkill list all 打开文件： sudo gedit /etc/modprobe.d/blacklist.conf 最后一行加入： blacklist ideapad_laptop 最后保存重启 新建用户并添加sudo权限 如果没有root用户 1sudo passwd root 新建用户 123456# 新建账号并自动建立用户目录sudo useradd -r -m -s /bin/bash username# 为用户username添加sudo权限sudo usermod -a -G sudo username# 去除用户username的sudo权限sudo usermod -G usergroup username 时间同步 使用date或timedatectl确认当前时间 如果看到System clock synchronized值为no，则重启该服务 1sudo systemctl restart systemd-timesyncd.service 如果仍然不起作用，请运行以下命令以启用时间同步： 1sudo timedatectl set-ntp true 如果非CST（中国标准时间），则更改时区 1sudo timedatectl set-timezone Asia/Shanghai ca-certificate失效手动下载最新的证书文件重新安装 123cd /tmpwget http://archive.ubuntu.com/ubuntu/pool/main/c/ca-certificates/ca-certificates_20230311ubuntu0.20.04.1_all.debsudo dpkg -i ./ca-certificates_20230311ubuntu0.20.04.1_all.deb 替换apt源 使用cat /etc/os-release或lsb_release -c命令确认当前ubuntu系统代号Codename 备份软件源配置文件 1sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak 拷贝，注意替换系统代号。 清华大学开源镜像站 中科大开源镜像站 1234567891011121314151617# 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-backports main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-backports main restricted universe multiverse# deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-security main restricted universe multiverse# # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-security main restricted universe multiversedeb http://security.ubuntu.com/ubuntu/ focal-security main restricted universe multiverse# deb-src http://security.ubuntu.com/ubuntu/ focal-security main restricted universe multiverse# 预发布软件源，不建议启用# deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-proposed main restricted universe multiverse# # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-proposed main restricted universe multiverse 更新 123sudo apt updatesudo apt upgrade -y --fix-missingsudo apt install -y --fix-missing 字体 consolas Fira Code","link":"/2023/11/14/Ubuntu%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"title":"Ubuntu安装Nginx","text":"Nginx 是开源的高性能 HTTP 和反向代理服务器，负责处理 Internet 上一些最大站点的负载。本文简单介绍了如何安装 Nginx 服务，以及如何配置反向代理、SSL加密等。 安装 NginxNginx 在默认的 Ubuntu 存储库中可用。要安装它，请使用 apt 命令运行以下命令，这将会更新软件包索引并且安装 Nginx 。 安装完成后，Nginx 服务将自动启动。您可以通过运行 systemctl 命令查看服务的状态，从而确定 Nginx 服务是否正常启动。 123sudo apt updatesudo apt install nginxsudo systemctl status nginx 配置反向代理步骤1：安装 Nginx确保已在服务器上安装了 Nginx。 步骤2：编辑 Nginx 配置文件 打开 Nginx 的配置文件，通常位于 /etc/nginx/nginx.conf 或 /etc/nginx/sites-available/default。 在配置文件中找到或添加一个 server 段落，根据需要进行配置。示例： 123456789101112server { listen 80; server_name example.com; location / { proxy_pass http://your_upstream_server; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; # 其他可能需要的配置项 }} listen 指定 Nginx 监听的端口号和协议。 server_name 是你的域名或服务器的 IP 地址。 location 是针对特定位置的配置。 proxy_pass 设置反向代理目标的地址。 proxy_set_header 用于设置请求头信息，确保转发后头信息正确传递。 根据实际情况自定义配置，确保代理地址、请求头设置等正确配置。 步骤3：检查配置并重启 Nginx使用以下命令检查 Nginx 配置是否有语法错误： 1sudo nginx -t 如果没有错误，重启 Nginx 服务以使更改生效： 1sudo systemctl restart nginx 配置 SSL 证书步骤1：获取 SSL 证书你可以从证书颁发机构（CA）购买 SSL 证书，或者使用免费的证书颁发机构（如 Let’s Encrypt）来获取证书。 如果使用 Let’s Encrypt 申请免费的证书，可以参考文章 Let's Encrypt免费申请SSL证书。 步骤2：将证书文件放到服务器上将你的 SSL 证书文件和私钥文件上传到服务器上。一般来说，这两个文件通常是 .crt 和 .key 格式的文件。 步骤3：编辑 Nginx 配置文件 打开 Nginx 的配置文件，一般位于 /etc/nginx/nginx.conf 或 /etc/nginx/sites-available/default。 在配置文件中找到服务器块（server），并对其进行修改以启用 SSL： 123456789server { listen 443 ssl; server_name example.com; ssl_certificate /path/to/your_domain.crt; ssl_certificate_key /path/to/your_private_key.key; # 其他 SSL 配置项} listen 443 ssl; 指定 Nginx 监听 SSL 加密的 443 端口。 ssl_certificate 指定你的 SSL 证书文件路径。 ssl_certificate_key 指定你的私钥文件路径。 添加其他 SSL 配置（可选），如 SSL 协议版本、加密套件等。 步骤4：检查配置并重启 Nginx使用以下命令检查 Nginx 配置是否有语法错误： 1sudo nginx -t 如果没有错误，重启 Nginx 服务以使更改生效： 1sudo systemctl restart nginx","link":"/2023/11/28/Ubuntu%E5%AE%89%E8%A3%85Nginx/"},{"title":"Ubuntu常用命令","text":"本文记录笔者在日常使用Ubuntu时常见的命令。 文件权限管理修改文件所属组群—chgrp12chgrp $group /path/to/change/groupchgrp -R $group /path/to/change/group # 改变同一目录下的所有文件夹 修改文件所有者—chown12chown $user /path/to/change/groupchown -R $user /path/to/change/group # 改变同一目录下的所有文件夹 文件权限—chmodLinux chmod 命令 | 菜鸟教程 权限位共有10位：第一位是文件类型，第二到四位是所有者，第五到七位是所属组，第八到十位是其他人。 自启动通过rc.local服务 将 /lib/systemd/system/rc-local.service 链接到 /etc/systemd/system/ 目录下面来 1ln -fs /lib/systemd/system/rc-local.service /etc/systemd/system/rc-local.service 修改rc-local.service文件内容 12345sudo echo &quot;[Install]WantedBy=multi-user.targetAlias=rc-local.service&quot; &gt;&gt; etc/systemd/system/rc-local.service 创建并编辑/etc/rc.local文件 12sudo touch /etc/rc.localsudo vim /etc/rc.local 把想开机启动的脚本放入 12#!/bin/bash[此处为脚本] 通过init.d脚本文件 编写脚本 1vim test.sh 先添加脚本内容抬头 1234567891011#!/bin/bash### BEGIN INIT INFO# Provides: test# Required-Start: $remote_fs $syslog# Required-Stop: $remote_fs $syslog# Default-Start: 2 3 4 5# Default-Stop: 0 1 6# Short-Description: start test# Description: start test### END INIT INFO 然后开始编写脚本内容 将编写的脚本放入/etc/init.d/ 1sudo mv test.sh /etc/init.d/ 给文件权限 1chmod +750 test.sh 设置开机自动启动 1sudo update-rc.d test.sh defaults NN NN为启动顺序，如果需要用到网络，则设置一个较大的数字如99. 卸载启动脚本 12cd /etc/init.dsudo update-rc.d -f test.sh remove 移除软件 1sudo apt-get --purge remove 软件名 磁盘分区fdisk命令详解： m：获取帮助 n：新建分区 p：显示分区表 d：删除分区 b：设置卷标 w：写入分区表 t：改变分区文件系统类型 v：检验分区 l：显示fdisk所支持的文件系统代码 q：退出 格式化分区12mkfs -t ext4 /dev/sda1mkfs -t ext4 /dev/sda2 后台进程管理 &amp;加在一个命令的最后，可以把这个命令放到后台执行 ,如gftp &amp;, ctrl + z可以将一个正在前台执行的命令放到后台，并且处于暂停状态，不可执行 jobs查看当前有多少在后台运行的命令jobs -l选项可显示所有任务的PID，jobs的状态可以是running, stopped, Terminated,但是如果任务被终止了（kill），shell 从当前的shell环境已知的列表中删除任务的进程标识；也就是说，jobs命令显示的是当前shell环境中所起的后台正在运行或者被挂起的任务信息； fg将后台中的命令调至前台继续运行如果后台中有多个命令，可以用 fg %jobnumber将选中的命令调出，%jobnumber是通过jobs命令查到的后台正在执行的命令的序号(不是pid) bg将一个在后台暂停的命令，变成继续执行 （在后台执行）如果后台中有多个命令，可以用bg %jobnumber将选中的命令调出，%jobnumber是通过jobs命令查到的后台正在执行的命令的序号(不是pid)将任务转移到后台运行：先ctrl + z；再bg，这样进程就被移到后台运行，终端还能继续接受命令。 ctrl+z（挂起）、ctrl+c（中断）、ctrl+\\（退出）和ctrl+d（EOF）的区别ctrl+c强行中断当前程序的执行。 ctrl+z将任务中断,但是此任务并没有结束,他仍然在进程中，只是放到后台并维持挂起的状态。如需其在后台继续运行，需用“bg 进程号”使其继续运行；再用”fg 进程号”可将后台进程前台化。 ctrl+\\表示退出。 ctrl+d表示结束当前输入（即用户不再给当前程序发出指令），那么Linux通常将结束当前程序。 清理空间to Server在服务器上使用ncdu 123sudo apt-get install ncdu# 以清理日志文件为例sudo ncdu /var/log to Client在桌面版本用图形化的baobab工具。 1sudo apt-get install baobab 压缩解压1234# 压缩tar -zcvf xx.tar.gz &lt;target folder&gt;/# 解压tar -zxvf xx.tar.gz &lt;destination folder&gt; 磁盘操作挂载磁盘 查看硬盘UUID 1sudo blkid 创建挂载点 1sudo mkdir /mnt/xxx 挂载 1mount /dev/xxx /mnt/xxx 开机自动挂载 123456# 修改/etc/fstab文件内容sudo vim /etc/fstab# 添加到文件UUID=XXX-XXX-XXX /mnt/xx ext4 defaults 0 2# 挂载NTFS文件系统UUID= /mnt/xxx ntfs defaults 0 2","link":"/2023/11/14/Ubuntu%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"title":"WSL2开发环境","text":"本文记录了笔者在WSL2中配置深度学习开发环境的主要步骤。 初始化WSL2环境具体实现过程参考 Ubuntu基础知识 部分。 安装远程桌面环境具体实现过程参考 Linux实现远程桌面环境。 配置当前用户执行sudo命令免密 由于启动xrdp服务需要用到sudo权限，会出现输入密码的提示，较为麻烦 创建配置文件 1sudo vim /etc/sudoers.d/[USERNAME] 编辑如下内容 1[USERNAME] ALL=(ALL) NOPASSWORD: ALL 创建一键启动脚本12mkdir ~/.local/bin -pvim ~/.local/bin/remote.sh 文件末尾追加下面两行内容 123sudo /etc/init.d/xrdp startsleep 1mstsc.exe /v:localhost:[PORT] 给脚本加上可执行权限 1chmod +x ~/.local/bin/remote.sh 在windows桌面新建一个快捷方式，对象位置内容填写: 1wsl ~/.local/bin/remote.sh 双击快捷方式即可实现一键启动登录wsl2远程桌面 CUDA on WSL2还没有开始研究过，可参考如下文章: CUDA on WSL User Guide Enabling GPU acceleration on Ubuntu on WSL2 with the NVIDIA CUDA Platform","link":"/2023/11/17/WSL2%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"},{"title":"Let&#39;s Encrypt免费申请SSL证书","text":"Let’s Encrypt 是免费、开放和自动化的证书颁发机构 (CA)。我们可以从 Let’s Encrypt 获得网站域名的免费的证书。 使用 certbot 申请 SSL 证书Certbot 是 Let’s Encrypt 官方推荐的获取证书的客户端，可以帮我们获取免费的 Let’s Encrypt 证书。Certbot 支持所有 Unix 内核的操作系统。 安装 certbotCertbot 官方推荐使用 snap 安装，当然你也可以使用 yum 或者 dnf。 安装 snapd Snap 已经预装在 Ubuntu 16.04 (Xenial Xerus) 及更新发行版本，如果使用旧版，可以手动安装 snap :) 12sudo apt update sudo apt install snapd 更多 OS 安装请参考文档。 移除旧版 如果此前使用过其他包管理工具进行安装 certbot，推荐在安装前移除: 123456# aptsudo apt-get remove certbot# dnfsudo dnf remove certbot# yumsudo yum remove certbot 安装 在命令行运行以下命令进行安装 1sudo snap install --classic certbot 准备 certbot 命令 创建软链以便在终端快捷使用 certbot 命令: 1sudo ln -s /snap/bin/certbot /usr/bin/certbot 运行 接下来，你就可以使用 certbot 来获取证书，或者对证书进行续约。具体细节请参考文档。 申请泛域名 SSL 证书以及配置自动续约不管是申请还是续期，只要是通配符证书，只能采用 dns-01 的方式校验申请者的域名，也就是说每次续期证书我们都必须登录控制台添加对应的 TXT 记录才可以续期/申请成功，这样不免有些麻烦。好在 certbot 提供了一个 hook，可以调用域名提供商的 API 接口来添加 TXT 记录而无需人工干预，但是官方并不支持国内的大部分服务商，这样就要用到第三方的插件了。此处我们使用的是 certbot-letencrypt-wildcardcertificates-alydns-au，本文仅简单介绍，更多细节请参考项目文档。 下载 123git clone https://github.com/ywdblog/certbot-letencrypt-wildcardcertificates-alydns-aucd certbot-letencrypt-wildcardcertificates-alydns-auchmod 0777 au.sh 配置 （1） domain.ini 如果 domain.ini 文件没有你的根域名，请自行添加。 （2） au.sh 登录域名服务商的控制台获取 API 密钥，然后配置在 au.sh 文件中。 ALY_KEY 和 ALY_TOKEN：阿里云 API key 和 Secrec 官方申请文档 TXY_KEY 和 TXY_TOKEN：腾讯云 API 密钥官方申请文档 HWY_KEY 和 HWY_TOKEN: 华为云 API 密钥官方申请文档 GODADDY_KEY 和 GODADDY_TOKEN：GoDaddy API 密钥官方申请文档 申请证书 首先我们测试是否有误： 123456sudo certbot certonly \\-d *.example.com \\--manual --preferred-challenges dns \\--dry-run \\--manual-auth-hook &quot;/脚本目录/au.sh php aly add&quot; \\--manual-cleanup-hook &quot;/脚本目录/au.sh php aly clean&quot; 注意： –manual-auth-hook 和 –manual-cleanup-hook 有三个参数： 第一个代表你要选择那种语言(php/python) 第二个参数代表你的DNS厂商(aly/txy) 第三个参数是固定的(–manual-auth-hook中用add，–manual-clean-hook中用clean) 比如你要选择Python环境，可以将 –manual-auth-hook 输入修改为 “/脚本目录/au.sh python aly add”，–manual-cleanup-hook 输入修改为 “/脚本目录/au.sh python aly clean” 确认无误后，实际运行（去除 –dry-run 参数）： 12345sudo certbot certonly \\-d *.example.com \\--manual --preferred-challenges dns \\--manual-auth-hook &quot;/脚本目录/au.sh php aly add&quot; \\--manual-cleanup-hook &quot;/脚本目录/au.sh php aly clean&quot; 参数解释: certonly：表示采用验证模式，只会获取证书，不会为 web 服务器配置证书 --manual：表示插件 --preferred-challenges dns：表示采用 DNS 验证申请者合法性（是不是域名的管理者） --dry-run：在实际申请/更新证书前进行测试，强烈推荐 -d：表示需要为那个域名申请证书，可以有多个。 --manual-auth-hook：在执行命令的时候调用一个 hook 文件 --manual-cleanup-hook：清除 DNS 添加的记录 续约 手动续约 1sudo certbot renew 自动续约 12345678# 编辑文件vim /etc/crontab或配置了crontab编辑器的情况下crontab -e# 填入以下内容1 1 */1 * * sudo certbot renew --manual --preferred-challenges dns --deploy-hook &quot;service nginx restart&quot; --manual-auth-hook &quot;/脚本目录/au.sh php aly add&quot; --manual-cleanup-hook &quot;/脚本目录/au.sh php aly clean&quot;# 注意只有成功renew证书，才会重新启动nginx","link":"/2023/12/01/%E5%85%8D%E8%B4%B9%E7%94%B3%E8%AF%B7SSL%E8%AF%81%E4%B9%A6/"},{"title":"内网穿透","text":"本文简单介绍内网穿透的几种方式。 根据网络情况—有无公网ip—选择适合自己的内网穿透方法。有公网ip的建议直接DDNS，无公网ip可选择以下方式: ZeroTier VPS + FRP VPS + WireGuard ZeroTier创建虚拟网段 登录ZeroTier官网创建一个网络，并选择路由表。 在需要内网穿透的终端上安装zerotier客户端并使用Network ID加入已创建的网络。 在ZT官网认证设备。 在ZT官网配置NAT: 192.168.x.0/24 via [Managed IP of OpenWrt]。 OpenWrt桥接物理局域网 将OpenWrt加入ZeroTier虚拟网段 在OpenWrt的ZeroTier客户端配置自动允许客户端NAT 配置防火墙，位置Openwrt防火墙→通信规则→添加新规则 12345名称: Allow-ZeroTier-Inbound协议: UDP源区域: 任意区域（转发）目标区域: 设备（输入）目标端口: 9993 在OpenWrt→网络→接口添加新接口： 1231. 名称ZeroTier2. 协议选择不配置协议3. 设备选&quot;以太网适配器ztxxxxx&quot;(此处ztxxxx由ZeroTier客户端自动创建的虚拟接口) 在OpenWrt→网络→防火墙的区域列表中新增： 12345678名称: ztvpn入站数据: 接受出站数据: 接受转发: 接受ip动态伪装: ✔涵盖网络: ZeroTier允许转发到目标区域: 选择lan允许来自源区域的转发: 选择lan","link":"/2023/11/21/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"},{"title":"深度学习环境配置","text":"本文记录了笔者在配置深度学习环境时的主要步骤。 OSInstall UbuntuRefer to Ubuntu基础知识. ProxyTerminal proxy Setup Nvidia driver &amp; cuda &amp; cudnn on linux systemOnly valid for Debian/Ubuntu system. Other Linux distribution is continued... N᠎OTE that the secure boot must be disable and the &quot;Driver&quot; must be disabled during the installation. DownloadFirst we should check the right version between Nvidia driver and CUDA Toolkit via https://docs.nvidia.com/cuda/cuda-toolkit-release-notes/index.html#cuda-major-component-versions__table-cuda-toolkit-driver-versions official url for Nvidia driver: https://www.nvidia.cn/Download/index.aspx?lang=cn official url for CUDA Toolkit: https://developer.nvidia.com/cuda-toolkit-archive official url for cuDNN: https://developer.nvidia.com/rdp/cudnn-download CleanStart terminal and remove any NVIDIA traces you may have on your machine. 123456789# ---clean nvidia-------------sudo apt-get purge nvidia*sudo apt remove nvidia-* libnvidia*# ----------------------------# if you installed nvidia-docker and only want to uninstall nvidia driver, you can use the following commandsudo /usr/bin/nvidia-uninstall# ---clean cuda---------------sudo /usr/local/cuda-xx.x/bin/cuda-uninstallersudo rm -rf /usr/local/cuda-xx.x Disable the inner nouveau nvidia driver, 123456789101112# run the command to new/edit a filesudo vim /etc/modprobe.d/blacklist.conf# add following lines to above fileblacklist nouveauoptions nouveau modeset=0# using following command to update the kernelsudo update-initramfs -u# reboot and check the driver modulelsmod | grep nouveau InstallSetup the correct CUDA PPA on your system 12345sudo add-apt-repository ppa:graphics-driverssudo apt updatesudo service gdm3 stop # or lightdm, kdm. Use 'cat /etc/X11/default-display-manager' command to check which display manager is used.sudo apt-get install dkms build-essential linux-headers-generic # install essential packages to build kernel modulesudo apt-get install linux-headers-$(uname -r) Install dirver, cuda and cudnn 1234567891011# First navigate to the folder where the nvidia driver is saved.# install driversudo sh NVIDIA-Linux-x86_64-470.63.01.run -no-opengl-files -no-x-check -no-nouveau-check# install cuda, note that don't select Driversudo sh cuda_11.1.1_455.32.00_linux.run# install cudnntar -xzvf cudnn-11.2-linux-x64-v8.1.1.33.tgzsudo cp cuda/lib64/* /usr/local/cuda-11.1/lib64/sudo cp cuda/include/* /usr/local/cuda-11.1/include/ As the last step one need to specify PATH to CUDA in ‘.bashrc’ file. Open the file by running: 1vim ~/.bashrc And add the following lines at the end of the file: 123export CUDA_HOME=/usr/local/cuda-xx.xexport LD_LIBRARY_PATH=${CUDA_HOME}/lib64export PATH=${CUDA_HOME}/bin:${PATH} Restart and check the versions for the installation. NVIDIA driver: 1nvidia-smi CUDA: 1nvcc -V cuDNN: 123/sbin/ldconfig -N -v $(sed ‘s/:/ /’ &lt;&lt;&lt; $LD_LIBRARY_PATH) 2&gt;/dev/null | grep libcudnn# orcat /usr/local/cuda/include/cudnn_version.h | grep CUDNN_MAJOR -A 2 Start display manager. 1sudo service gdm3 start Setup remote desktopAfter updates, run below command to install XRDP on your server 1sudo apt-get install xrdp Step 1: Install your preferred desktop environmentTo install XFCE, please use below command 123sudo apt-get install xfce4# optionalsudo apt-get install xfce4-terminal After installation, configure XRDP to use XFCE environment with below command（may be unnecessary, need to test） 1sudo sed -i.bak '/fi/a #xrdp multiple users configuration \\n xfce-session \\n' /etc/xrdp/startwm.sh By default Xrdp uses the /etc/ssl/private/ssl-cert-snakeoil.key file which is readable only by users that are members of the “ssl-cert” group. Execute thefollowing command to add the xrdp user to the group 1sudo adduser xrdp ssl-cert Step 2: Allow RDP port in FirewallPost configuring, To connect with the RDP session you need to allow the port in firewall which by default is closed. Run the below command to open the port in Ubuntu 18.04 If you have enabled UFW, Use below command 123456# optional, 如果没有ufw命令请安装sudo apt-get install ufw# ---------------------------------sudo ufw allow 3389/tcp# 或者关闭防火墙sudo ufw disable (Optional) If Iptables is running on your server, Use below command 123sudo iptables -A INPUT -p tcp --dport 3389 -j ACCEPTsudo netfilter-persistent savesudo netfilter-persistent reload Step 3: Restart the Xrdp applicationRestart once the Xrdp application to make sure all the above changes are reflected. 1sudo systemctl restart xrdp Run the following commands only once the first time you log on the machine 1echo xfce4-session &gt;~/.xsession Step 4: Address the black screen problemedit the startwm.sh file 1234567891011$ sudo vim /etc/xrdp/startwm.sh# append the following code piece before the specific positionunset DBUS_SESSION_BUS_ADDRESSunset XDG_RUNTIME_DIR. $HOME/.profile←if test -r /etc/profile; then......fi","link":"/2023/11/14/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"},{"title":"终端代理","text":"本文记录笔者在遇到需要对终端命令代理时找到的几种解决方案。 Windows platform临时生效在windows的cmd命令行执行下面命令： 123456# 使用socks5代理set http_proxy=socks5://127.0.0.1:端口号set https_proxy=socks5://127.0.0.1:端口号# 使用http代理set http_proxy=http://127.0.0.1:端口号set https_proxy=http://127.0.0.1:端口号 取消设置 12set http_proxy=set https_proxy= 长期生效在我的电脑 -&gt; 属性-&gt; 高级系统设置-&gt; 高级-&gt; 环境变量，然后在 系统环境中，新建两个系统环境变量，变量名称分别为 https_proxy和http_proxy，值为 https_proxy=socks5://127.0.0.1:端口号 测试在cmd命令行使用curl www.google.com，如果有内容返回，说明设置成功（不可以用ping命令测试）。 如果遇到报错信息：curl : 无法分析响应内容，因为 Internet Explorer 引擎不可用，或者 Internet Explorer 的首次启动配置不完整。请指定 UseBasicParsing 参数，然后再试一次，可以参考https://www.cnblogs.com/sjfeng1987/p/10000493.html Ubuntu 安装proxychains 1sudo apt install proxychains 配置proxychains.conf文件 1234vim /etc/proxychains.confsocks5 127.0.0.1 1080http 127.0.0.1 1080 在[ProxyList]这一行下添加socks5 127.0.0.1 1080，如果有别的比如socks4 127.0.0.1 9050那么就把它给注释掉 使用方法 如使用git clone： 1proxychains git clone https://github.com/haad/proxychains.git 参考 https://www.cnblogs.com/hi-eric/p/11563245.html","link":"/2023/11/14/%E7%BB%88%E7%AB%AF%E4%BB%A3%E7%90%86/"},{"title":"部署FRP实现内网穿透","text":"本文粗略记录了配置FRP的过程。 下载客户端和服务器都要下载文件：https://github.com/fatedier/frp/releases 然后在客户机（也就是需要进行内网穿透的本地机）和服务器执行相同操作： 123456# 解压tar -xvzf frp_xxx_linux_amd64.tar.gz# 移动文件sudo mv frp_xxx_linux_amd64 /usr/local/frp# 进入移动后的文件夹cd /usr/local/frp 服务器配置 登录到服务器终端，修改frps配置文件 12345678# 首先确保当前已经在frp目录内，如果不在请输入下面命令$ cd /usr/local/frp# 修改frps配置文件$ sudo vim frps.ini[common]bind_port = 33300 # frps监听端口，根据需要自行修改token = xxxx 在服务器设置中找到防火墙管理规则，开放暴露端口 一个33300端口，一个33301端口用于提供ssh服务 注册为系统服务 123456789101112131415$ chmod 777 frps$ sudo vim /usr/lib/systemd/system/frps.service[Unit]Description=frps ServiceDocumentation=https://github.com/fatedier/frpAfter=network.target nss-lookup.target[Service]ExecStart=/usr/local/frp/frps -c /usr/local/frp/frps.ini Restart=on-failureRestartPreventExitStatus=23[Install]WantedBy=multi-user.target 重载服务：systemctl daemon-reload 开启服务：systemctl start frps 查看服务状态：systemctl status frpc 设置开机自启动：systemctl enable frps 客户端配置 修改客户端配置 123456789101112$ sudo vim /usr/local/frp/frpc.ini[common]server_addr = 你的服务器公网ipserver_port = 33300tls_enable = true[ssh]type = tcplocal_ip = 127.0.0.1local_port = 22remote_port = 33301 # ssh端口 注册为系统服务 1234567891011121314$ sudo vim /usr/lib/systemd/system/frpc.service[Unit]Description=frps ServiceDocumentation=https://github.com/fatedier/frpAfter=network.target nss-lookup.target[Service]ExecStart=/usr/local/frp/frpc -c /usr/local/frp/frpc.iniRestart=on-failureRestartPreventExitStatus=23[Install]WantedBy=multi-user.target 重载服务：systemctl daemon-reload 开启服务：systemctl start frpc 查看服务状态：systemctl status frpc 设置开机自启动：systemctl enable frpc SSH连接1ssh -p 33301 username@ip","link":"/2023/11/20/%E9%83%A8%E7%BD%B2FRP%E5%AE%9E%E7%8E%B0%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"}],"tags":[{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"PyTorch","slug":"PyTorch","link":"/tags/PyTorch/"},{"name":"Docker","slug":"Docker","link":"/tags/Docker/"},{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"Nginx","slug":"Nginx","link":"/tags/Nginx/"},{"name":"Network","slug":"Network","link":"/tags/Network/"},{"name":"Windows","slug":"Windows","link":"/tags/Windows/"},{"name":"SSL","slug":"SSL","link":"/tags/SSL/"},{"name":"CUDA","slug":"CUDA","link":"/tags/CUDA/"}],"categories":[{"name":"DL","slug":"DL","link":"/categories/DL/"},{"name":"ToolKits","slug":"ToolKits","link":"/categories/ToolKits/"},{"name":"OS","slug":"OS","link":"/categories/OS/"},{"name":"ToolKits","slug":"OS/ToolKits","link":"/categories/OS/ToolKits/"}],"pages":[]}